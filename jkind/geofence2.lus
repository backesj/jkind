--------------------------------------------------------------------------------
--+----------------------------------------------------------------------------+
--|                                                                            |
--|                                                                            |
--|                                                                            |
--|                                                                            |
--|           +-----------------+             +-----------------+              |
--|   fence   |                 |             |                 |              |
--+----------->     Mission     |             |   Controller    |              |
--|           |     Planner     |    plan     |                 |   location   |
--|           |                 +------------->                 +-------------->
--|   dest    |                 |             |                 |              |
--+----------->                 |             |                 |              |
--|           |                 |             |                 |              |
--|           +-----------------+             +-----------------+              |
--|                                                                            |
--|                                                                            |
--|                                                                            |
--|                                                                            |
--|                                                                            |
--|                                                                            |
--+----------------------------------------------------------------------------+
--------------------------------------------------------------------------------
--
-- This lustre file models a system of two components: a "Mission Planner" and a
-- "Controller".  The system contains two inputs a "fence" and a "destination".
-- The role of the mission planner is to generate a "plan" which is a set of 
-- waypoints within the last fence received by the mission planner.  The final
-- waypoint of the plan is the last destination received by the mission planner.
-- 
-- The controller guarantees that it either remains in the same location or 
-- moves towards the next coordinate in the given plan. The plan is modeled
-- as a possibly infinite list of x,y coordinates, and the fence is modeled
-- as a rectangle.  We prove the following properties for this system:
--
-- P0. If the previous location was within the fence, then the next location
--     is in the fence unless the system recently received a new fence
--
-- P1. The plan being executed by the controller is always within the most 
--     recent fence received by the mission computer, Except in the instant
--     that a new fence is received.
--       
-- P2. The mission computer's last received destination is the last coordinate
--     in the plan being executed by the controller, except in the instant that
--     a new destination is received.
--
-- P3. If the location is outside of the fence and no new fence was received 
--     recently, then the Manhattan distance from the perimeter of the fence
--     either remains the same or decreases.
--
--------------------------------------------------------------------------------

type Coord = induct {point (x int) (y int)};
type CoordLst = induct {cons (head Coord) (tail CoordLst) | nil };
type Fence = induct {corners (top int) (bottom int) (left int) (right int)};

recursive coordInFence(
  fence : Fence;
  coord : Coord)
returns(
  ret: bool);
let
  ret = if (x coord) <= (right fence) and 
           (x coord) >= (left fence) and
           (y coord) <= (top fence) and
           (y coord) >= (bottom fence) then
             true
        else
             false;
tel;

recursive planEndsInCoord(
  plan : CoordLst;
  dest : Coord)
returns(
  ret : bool);
let
  ret = if (is_nil plan) then
          false
        else if (is_nil (tail plan)) then
          (head plan) = dest
        else
          (planEndsInCoord (tail plan) dest);
tel;

recursive planInFence(
  fence : Fence;
  coords : CoordLst)
returns(
  ret: bool);
let
  ret = if (is_nil coords) then
          true
        else
          (coordInFence fence (head coords)) and
          (planInFence fence (tail coords));
tel;

node abs (x : int) returns (ret : int);
let
  ret = if x < 0 then
          -1 * x
        else
          x;
tel;

node min(x : int; y : int) returns (ret : int);
let
  ret = if (x < y) then x else y;
tel;

node main(
  dest : Coord; 
  fence : Fence;
  misPlan : CoordLst;
  location: Coord;
  gotFence : bool;
  gotDest : bool;
  newPlan : bool)
returns ();
var
  prop0 : bool;
  prop1 : bool;
  prop2 : bool;
  prop3 : bool;
  lemma0 : bool;
  misFence : Fence;
  misDest : Coord;
  locInMisFence : bool;
  nextPoint : Coord;
  ctrPlan : CoordLst;
  curXDist : int;
  preXDist : int;
  curYDist : int;
  preYDist : int;
  nextPointInMisFence : bool;
  xDistToFence : int;
  yDistToFence : int;
let
  --BEGIN MISSION PLANNER VARIABLES
  misFence = if (gotFence) then fence else ((corners 0 0 0 0) -> pre(misFence));
  misDest = if (gotDest) then dest else ((point 0 0) -> pre(misDest));
    
  --BEGIN CONTROLLER VARIABLES
  ctrPlan = nil ->
                   (if pre(newPlan) then
                     pre(misPlan)
                   else if (is_cons (pre ctrPlan)) and
                           pre(location) = (head (pre ctrPlan)) then
                     (tail (pre ctrPlan))
                   else
                     pre(ctrPlan));
          
  
  nextPoint = (point 0 0) ->
              if (is_nil ctrPlan) then
                pre(location)
              else
                (head ctrPlan);
                
  --BEGIN MISSION PLANNER GUARANTEES
  
  --The mission planner guarantees that it always provides a plan
  --that falls within the current geofence
  
  assert (planInFence misFence misPlan);
  
  --if we got a new fence we need a new plan
  
  assert gotFence => newPlan;
  
  --if we got a new destination we need a new plan
  
  assert gotDest => newPlan;
  
  --We never send a blank plan
  
  assert (newPlan => not (is_nil misPlan));
  
  --If we have a plan it always has the distination in it
  
  assert not (is_nil misPlan) => (planEndsInCoord misPlan misDest);
  
  --BEGIN CONTROLLER GUARANTEES
  
  --the controller is always initially at point 0,0
  assert( (location = (point 0 0)) -> true);
  
  --The controller guarantees that it always stays within the same distance
  --or moves towards its next coordinate
  
  curXDist = 0 -> (x location) - (x pre(nextPoint));
  preXDist = 0 -> (x pre(location)) - (x pre(nextPoint));
  
  curYDist = 0 -> (y location) - (y pre(nextPoint));
  preYDist = 0 -> (y pre(location)) - (y pre(nextPoint));
  
  assert preXDist <= 0 => curXDist <= 0 and curXDist >= preXDist;
  assert preYDist <= 0 => curYDist <= 0 and curYDist >= preYDist;
  
  assert preXDist >= 0 => curXDist >= 0 and curXDist <= preXDist;
  assert preYDist >= 0 => curYDist >= 0 and curYDist <= preYDist;
  
  --BEGIN SYSTEM ASSUMPTIONS
  
  --We assume that if we get a new geofence then the current
  --destination lies within this fence
  
  assert(gotFence => (coordInFence fence misDest));
                  
  --BEGIN SYSTEM VARIABLES

  locInMisFence = (coordInFence misFence location);
  nextPointInMisFence = (coordInFence misFence nextPoint);
  
  --BEGIN PROPERTIES
  
  --if we are not in the fence then:
  --1. The fence is new.
  --2. We were previously not in the fence.
  
  lemma0 = true -> (is_nil ctrPlan) => location = pre(location);
  prop0 = true -> pre(locInMisFence and not gotFence) => locInMisFence or gotFence;
  
  --The controller's plan is always within the mission computer's fence
  --unless we just received a new fence            
  
  prop1 = not gotFence => (planInFence misFence ctrPlan);

  --The destination is at the end of the plan (if we did not just get a new one)
  
  prop2 = not gotDest => (not (is_nil ctrPlan)) => (planEndsInCoord ctrPlan misDest);

  --If we are outside the fence, then we do not move away from the fence
  
  xDistToFence = (min( abs((x location) - (left misFence)), abs((x location) - (right misFence))));
  yDistToFence = (min( abs((y location) - (top misFence)), abs((y location) - (bottom misFence))));
  
  prop3 = true -> not (pre(locInMisFence or gotFence) or gotFence) => 
    (locInMisFence or
    (xDistToFence <= pre(xDistToFence) or yDistToFence <= pre(yDistToFence)));

  --%PROPERTY lemma0;
  --%PROPERTY prop0;
  --%PROPERTY prop1;
  --%PROPERTY prop2;
  --%PROPERTY prop3;
  
tel;
  

