type Coord = induct {point (x int) (y int)};
type CoordLst = induct {cons (head Coord) (tail CoordLst) | nil };
type Fence = induct {corners (top int) (bottom int) (left int) (right int)};

recursive coordInFence(
  fence : Fence;
  coord : Coord)
returns(
  ret: bool);
let
  ret = if (x coord) <= (right fence) and 
           (x coord) >= (left fence) and
           (y coord) <= (top fence) and
           (y coord) >= (bottom fence) then
             true
        else
             false;
tel;

recursive planInFence(
  fence : Fence;
  coords : CoordLst)
returns(
  ret: bool);
let
  ret = if (is_nil coords) then
          true
        else
          (coordInFence fence (head coords)) and
          (planInFence fence (tail coords));
tel;

node abs (x : int) returns (ret : int);
let
  ret = if x < 0 then
          -1 * x
        else
          x;
tel;

node hist (x : bool) returns (r : bool);
let
  r = x -> x and pre(r);
tel;

node main(
  dest : Coord; 
  fence : Fence;
  misPlan : CoordLst;
  location: Coord;
  gotFence : bool;
  newPlan : bool)
returns ();
var
  prop0 : bool;
  prop1 : bool;
  misFence : Fence;
  locInMisFence : bool;
  nextPoint : Coord;
  ctrPlan : CoordLst;
  curXDist : int;
  preXDist : int;
  curYDist : int;
  preYDist : int;
  nextPointInMisFence : bool;
let
  --BEGIN MISSION PLANNER VARIABLES
  misFence = if (gotFence) then fence else ((corners 0 0 0 0) -> pre(misFence));
    
  --BEGIN CONTROLLER VARIABLES
  ctrPlan = nil ->
                   (if pre(newPlan) then
                     pre(misPlan)
                   else if (is_cons (pre ctrPlan)) and
                           pre(location) = (head (pre ctrPlan)) then
                     (tail (pre ctrPlan))
                   else
                     pre(ctrPlan));
          
  
  nextPoint = (point 0 0) ->
              if (is_nil ctrPlan) then
                pre(location)
              else
                (head ctrPlan);
                
  --BEGIN SYSTEM VARIABLES

  locInMisFence = (coordInFence misFence location);
  nextPointInMisFence = (coordInFence misFence nextPoint);
  
  
  --BEGIN MISSION PLANNER GUARANTEES
  
  --The mission planner guarantees that it always provides a plan
  --that falls within the current geofence
  
  assert (planInFence misFence misPlan);
  
  --The plan only changes if the destination changes or the fence
  --changes
  
  assert (newPlan => gotFence);
  assert true -> (misPlan <> pre(misPlan)) => newPlan;
  
  --if we got a new fence we need a new plan
  
  assert gotFence => newPlan;
  
  --We never send a blank plan
  
  assert (newPlan => not (is_nil misPlan));
  
  --BEGIN CONTROLLER GURANTEES
  
  --the controller is always initially at point 0,0
  assert( (location = (point 0 0)) -> true);
  
  --The controller guarantees that it always stays within the same distance
  --or moves towards its next coordinate
  
  curXDist = 0 -> (x location) - (x pre(nextPoint));
  preXDist = 0 -> (x pre(location)) - (x pre(nextPoint));
  
  curYDist = 0 -> (y location) - (y pre(nextPoint));
  preYDist = 0 -> (y pre(location)) - (y pre(nextPoint));
  
  assert preXDist <= 0 => curXDist <= 0 and curXDist >= preXDist;
  assert preYDist <= 0 => curYDist <= 0 and curYDist >= preYDist;
  
  assert preXDist >= 0 => curXDist >= 0 and curXDist <= preXDist;
  assert preYDist >= 0 => curYDist >= 0 and curYDist <= preYDist;
  
  
  --BEGIN SYSTEM ASSUMPTIONS
  
  --We assume that if we get a new geofence then the current
  --destination lies within this fence
  
  --assert(gotFence => (coordInFence fence misDest));
  
  --BEGIN PROPERTIES
  
  --if we are not in the fence then:
  --1. The fence is new and we have not re-entered.
  --2. We were previously not in the fence.
  
  prop0 = not locInMisFence => (true -> pre(gotFence) or gotFence or pre(not locInMisFence));
  
  --The controllers plan is always within the mission computers fence
  --unless we just received a new fence            
  
  prop1 = not gotFence => (planInFence misFence ctrPlan);
  
  --%PROPERTY prop0;
  --%PROPERTY prop1;
  
tel;
  

